# 闭包 
---

什么是闭包，闭包是这门语言中非常重要但又难以掌握，近乎神话的概念。但是如果了解了词法作用域，那么闭包的概念是不言自明的。

从闭包定义来说，当函数可以记住并访问所在的词法作用域，就产生了闭包，即使函数在当前词法作用域外执行。先来看下面这段代码:

```js
function demo() {
    var a = 2;
    function bar() {
        console.log(a);   // 2
    }
    bar();
}

demo();
```
这段代码中函数bar可以访问外部作用域中的变量a，那么这是闭包么？从技术来讲，也许是。但是根据前面的定义，确切的来说并不是闭包。

下面我们再来看一段代码:

```js
function demo() {
    var a = 2;
    function bar() {
        console.log(a);
    }
    return bar;
}

var baz = demo();
baz();   //2 这就是闭包的效果
```
以上代码清晰的展示了闭包。函数bar()的词法作用域能够访问demo()的内部作用域。然后我们将bar()函数本身当作一个值类型进行传递。在这个例子
中，我们将bar所引用的函数对象本身当作返回值。在demo()执行后，其返回值（也就是内部的bar()函数）赋值给变量baz并调用baz()，实际上只是通
过不同的标识符引用调用了内部的函数bar()。bar()显然可以被正常执行。但是在这个例子中，它在自己定义的词法作用域以外的地方执行。

在demo()执行后，通常会期待demo()的整个内部作用域都被销毁，因为我们知道引擎有垃圾回收器用来释放不再使用的内存空间。由于看上去demo()的
内容不会再被使用，所以很自然地会考虑对其进行回收。**而闭包的“神奇”之处正是可以阻止这件事情的发生。** 事实上内部作用域依然存在，因此没
有被回收。谁在使用这个内部作用域？原来是bar()本身在使用。拜bar()所声明的位置所赐，它拥有涵盖demo()内部作用域的闭包，使得该作用域能够
一直存活，以供bar()在之后任何时间进行引用。**bar()依然持有对该作用域的引用，而这个引用就叫作闭包。** 因此，在几微秒之后变量baz被实际
调用（调用内部函数bar），不出意外它可以访问定义时的词法作用域，因此它也可以如预期般访问变量a。

当然，无论使用何种方式对函数类型的值进行传递，当函数在别处被调用时都可以观察到闭包：
```js
function demo() {
    var a = 2;
    function bar() {
        console.log(a);
    }
    baz(bar);
}

function baz(fn) {
    fn();   //这就是闭包
}
```
把内部函数baz传递给bar，当调用这个内部函数时（现在叫作fn），它涵盖的demo()内部作用域的闭包就可以观察到了，因为它能够访问a。

传递函数当然也可以是间接的:
```js
var fn;

function demo() {
    var a = 2;
    function bar() {
        console.log(a);
    }
    fn = bar;   //将bar分配给全局变量
}

function baz() {
    fn();   // 这就是闭包
}

demo();
baz();   // 2
```
无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。

我们再来看一个例子:
```js
function demo(mes) {
    setTimeout(function () {
        console.log(mes)
    },1000)
}

demo("这也是闭包!");
```
将一个内部函数传递给setTimeout(..)。内部函数具有涵盖demo(..)作用域的闭包，因此还保有对变量mes的引用。demo(..)执行1000毫秒后，它的
内部作用域并不会消失，内部函数依然保有demo(..)作用域的闭包。

本质上无论何时何地，如果将（访问它们各自词法作用域的）函数当作第一级的值类型并到处传递，你就会看到闭包在这些函数中的应用。在定时器、事
件监听器、Ajax请求、跨窗口通信、Web Workers或者任何其他的异步（或者同步）任务中，只要使用了回调函数，实际上就是在使用闭包！

再来看一段IIFE的代码：
```js
var a = 2;
(function demo() {
    console.log(a);
})();
```
通常认为IIFE是典型的闭包例子,以上代码也可以正常运行，但严格来讲它并不是闭包。为什么？因为函数（示例代码中的demo）并不是在它本身的词法
作用域以外执行的。它在定义时所在的作用域中执行（而外部作用域，也就是全局作用域也持有a）。a是通过普通的词法作用域查找而非闭包被发现的。

尽管IIFE本身并不是观察闭包的恰当例子，但它的确创建了闭包，并且也是最常用来创建可以被封闭起来的闭包的工具。因此IIFE的确同作用域息息相
关，即使本身并不会真的创建作用域。

我们再来分析一段代码，思考一下它的运行结果是什么：
```js
for (var i=0;i<5;i++){
    setTimeout(function () {
        console.log(i)
    },i*1000)
}
```
通过运行，我们知道这段代码在运行时会以每秒一次的频率输出五次5。这似乎并不符合我们的预期，想想这是为什么?

延迟函数的回调会在循环结束时才执行。事实上，当定时器运行时即使每个迭代中执行的是setTimeout(.., 0)，所有的回调函数依然是在循环结束后才
会被执行，因此会每次输出一个5出来。

那么到底要如何改写才能符合预期呢？
```js
for (var i=0;i<5;i++){
    (function () {
        setTimeout(function () {
            console.log(i)
        },i*1000)
    })()
}
```

运行后发现并不可行。每个延迟函数都会将IIFE在每次迭代中创建的作用域封闭起来。如果作用域是空的，那么仅仅将它们进行封闭是不够的。仔细看一
下，我们的IIFE只是一个什么都没有的空作用域。它需要包含一点实质内容才能为我们所用。它需要有自己的变量，用来在每个迭代中储存i的值：
```js
for (var i=0;i<5;i++){
    (function () {
        var j = i;
        setTimeout(function () {
            console.log(j)
        },j*1000)
    })()
}
```

可以对这段代码进行一些改进：
```js
for (var i=0;i<5;i++){
    (function (j) {
        setTimeout(function () {
            console.log(j)
        },j*1000)
    })(i);
}
```
当然，这些IIFE也不过就是函数，因此我们可以将i传递进去，如果愿意的话可以将变量名定为j，当然也可以还叫作i。无论如何这段代码现在可以工作
了。在迭代内使用IIFE会为每个迭代都生成一个新的作用域，使得延迟函数的回调可以将新的作用域封闭在每个迭代内部，每个迭代中都会含有一个具有
正确值的变量供我们访问。好了，问题解决啦！

当然我们可以使用块级作用域更好的解决这个问题，看看下面的代码:
```js
for (var i=0;i<5;i++){
    let j = i;
    setTimeout(function () {
        console.log(j)
    },j*1000)
}
```

for循环头部的let声明还会有一个特殊的行为。这个行为指出变量在循环过程中不止被声明一次，每次迭代都会声明。随后的每个迭代都会使用上一个迭
代结束时的值来初始化这个变量。
```js
for (let i=0;i<5;i++){
    setTimeout(function () {
        console.log(i)
    },i*1000)
}
```
